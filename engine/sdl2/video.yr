mod sdl2::video;

import sdl2::rect;
import sdl2::surface;

pub struct
| format : u32
| w : i32
| h : i32
| refresh_rate : i32
| driverdata : &(void)
 -> SDL_DisplayMode;


pub struct
 -> SDL_Window;


pub enum
| SDL_WINDOW_FULLSCREEN = 0x00000001u32        /**< fullscreen window */
| SDL_WINDOW_OPENGL = 0x00000002u32             /**< window usable with OpenGL context */
| SDL_WINDOW_SHOWN = 0x00000004u32              /**< window is visible */
| SDL_WINDOW_HIDDEN = 0x00000008u32             /**< window is not visible */
| SDL_WINDOW_BORDERLESS = 0x00000010u32         /**< no window decoration */
| SDL_WINDOW_RESIZABLE = 0x00000020u32          /**< window can be resized */
| SDL_WINDOW_MINIMIZED = 0x00000040u32          /**< window is minimized */
| SDL_WINDOW_MAXIMIZED = 0x00000080u32          /**< window is maximized */
| SDL_WINDOW_INPUT_GRABBED = 0x00000100u32      /**< window has grabbed input focus */
| SDL_WINDOW_INPUT_FOCUS = 0x00000200u32        /**< window has input focus */
| SDL_WINDOW_MOUSE_FOCUS = 0x00000400u32        /**< window has mouse focus */
| SDL_WINDOW_FULLSCREEN_DESKTOP = ( 0x00000001u32 | 0x00001000u32 )
| SDL_WINDOW_FOREIGN = 0x00000800u32            /**< window not created by SDL */
| SDL_WINDOW_ALLOW_HIGHDPI = 0x00002000u32      /**< window should be created in high-DPI mode if supported. On macOS NSHighResolutionCapable must be set true in the application's Info.plist for this to have any effect. */
| SDL_WINDOW_MOUSE_CAPTURE = 0x00004000u32      /**< window has mouse captured (unrelated to INPUT_GRABBED) */
| SDL_WINDOW_ALWAYS_ON_TOP = 0x00008000u32      /**< window should always be above others */
| SDL_WINDOW_SKIP_TASKBAR  = 0x00010000u32      /**< window should not be added to the taskbar */
| SDL_WINDOW_UTILITY       = 0x00020000u32      /**< window should be treated as a utility window */
| SDL_WINDOW_TOOLTIP       = 0x00040000u32      /**< window should be treated as a tooltip */
| SDL_WINDOW_POPUP_MENU    = 0x00080000u32      /**< window should be treated as a popup menu */
| SDL_WINDOW_VULKAN        = 0x10000000u32       /**< window usable for Vulkan surface */
 -> SDL_WindowFlags;

pub enum
| SDL_WINDOWEVENT_NONE = 0u32           /**< Never used */
| SDL_WINDOWEVENT_SHOWN = 1u32        /**< Window has been shown */
| SDL_WINDOWEVENT_HIDDEN = 2u32       /**< Window has been hidden */
| SDL_WINDOWEVENT_EXPOSED = 3u32      /**< Window has been exposed and should be redrawn */
| SDL_WINDOWEVENT_MOVED = 4u32          /**< Window has been moved to data1 data2 */
| SDL_WINDOWEVENT_RESIZED = 5u32        /**< Window has been resized to data1xdata2 */
| SDL_WINDOWEVENT_SIZE_CHANGED = 6u32   /**< The window size has changed either as a result of an API call or through the system or user changing the window size. */
| SDL_WINDOWEVENT_MINIMIZED = 7u32      /**< Window has been minimized */
| SDL_WINDOWEVENT_MAXIMIZED = 8u32      /**< Window has been maximized */
| SDL_WINDOWEVENT_RESTORED = 9u32       /**< Window has been restored to normal size and position */
| SDL_WINDOWEVENT_ENTER = 10u32          /**< Window has gained mouse focus */
| SDL_WINDOWEVENT_LEAVE = 11u32          /**< Window has lost mouse focus */
| SDL_WINDOWEVENT_FOCUS_GAINED = 12u32   /**< Window has gained keyboard focus */
| SDL_WINDOWEVENT_FOCUS_LOST = 13u32     /**< Window has lost keyboard focus */
| SDL_WINDOWEVENT_CLOSE = 14u32          /**< The window manager requests that the window be closed */
| SDL_WINDOWEVENT_TAKE_FOCUS = 15u32     /**< Window is being offered a focus (should SetWindowInputFocus() on itself or a subwindow or ignore) */
| SDL_WINDOWEVENT_HIT_TEST = 16u32        /**< Window had a hit test that wasn't SDL_HITTEST_NORMAL. */
 -> SDL_WindowEventID;

pub struct
 -> SDL_GLContext;


/**
 *  \brief Event subtype for display events
 */
pub enum
| SDL_DISPLAYEVENT_NONE = 0          /**< Never used */
| SDL_DISPLAYEVENT_ORIENTATION = 1    /**< Display orientation has changed to data1 */
 -> SDL_DisplayEventID;

pub enum
| SDL_ORIENTATION_UNKNOWN = 0            /**< The display orientation can't be determined */
| SDL_ORIENTATION_LANDSCAPE = 1         /**< The display is in landscape mode, with the right side up, relative to portrait mode */
| SDL_ORIENTATION_LANDSCAPE_FLIPPED = 2  /**< The display is in landscape mode, with the left side up, relative to portrait mode */
| SDL_ORIENTATION_PORTRAIT = 3           /**< The display is in portrait mode */
| SDL_ORIENTATION_PORTRAIT_FLIPPED = 4    /**< The display is in portrait mode, upside down */
 -> SDL_DisplayOrientation;

/**
 *  \brief OpenGL configuration attributes
 */
pub enum
| SDL_GL_RED_SIZE = 0
| SDL_GL_GREEN_SIZE = 1
| SDL_GL_BLUE_SIZE = 2
| SDL_GL_ALPHA_SIZE = 3
| SDL_GL_BUFFER_SIZE = 4
| SDL_GL_DOUBLEBUFFER = 5
| SDL_GL_DEPTH_SIZE = 6
| SDL_GL_STENCIL_SIZE = 7
| SDL_GL_ACCUM_RED_SIZE = 8
| SDL_GL_ACCUM_GREEN_SIZE = 9
| SDL_GL_ACCUM_BLUE_SIZE = 10
| SDL_GL_ACCUM_ALPHA_SIZE = 11
| SDL_GL_STEREO = 12
| SDL_GL_MULTISAMPLEBUFFERS = 13
| SDL_GL_MULTISAMPLESAMPLES = 14
| SDL_GL_ACCELERATED_VISUAL = 15
| SDL_GL_RETAINED_BACKING = 16
| SDL_GL_CONTEXT_MAJOR_VERSION = 17
| SDL_GL_CONTEXT_MINOR_VERSION = 18
| SDL_GL_CONTEXT_EGL = 19
| SDL_GL_CONTEXT_FLAGS = 20
| SDL_GL_CONTEXT_PROFILE_MASK = 21
| SDL_GL_SHARE_WITH_CURRENT_CONTEXT = 22
| SDL_GL_FRAMEBUFFER_SRGB_CAPABLE = 23
| SDL_GL_CONTEXT_RELEASE_BEHAVIOR = 24
| SDL_GL_CONTEXT_RESET_NOTIFICATION = 25
| SDL_GL_CONTEXT_NO_ERROR = 26
 -> SDL_GLattr;

pub enum
| SDL_GL_CONTEXT_PROFILE_CORE           = 0x0001
| SDL_GL_CONTEXT_PROFILE_COMPATIBILITY  = 0x0002
| SDL_GL_CONTEXT_PROFILE_ES             = 0x0004 /**< GLX_CONTEXT_ES2_PROFILE_BIT_EXT */
 -> SDL_GLprofile;

pub enum
| SDL_GL_CONTEXT_DEBUG_FLAG              = 0x0001
| SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG = 0x0002
| SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG      = 0x0004
| SDL_GL_CONTEXT_RESET_ISOLATION_FLAG    = 0x0008
 ->  SDL_GLcontextFlag;

pub enum
| SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE   = 0x0000
| SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH  = 0x0001
 -> SDL_GLcontextReleaseFlag;

pub enum
| SDL_GL_CONTEXT_RESET_NO_NOTIFICATION = 0x0000
| SDL_GL_CONTEXT_RESET_LOSE_CONTEXT    = 0x0001
 -> SDL_GLContextResetNotification;

/* Function prototypes */

/**
 *  \brief Get the number of video drivers compiled into SDL
 *
 *  \sa SDL_GetVideoDriver()
 */
pub extern (C) def SDL_GetNumVideoDrivers()-> i32;

/**
 *  \brief Get the name of a built in video driver.
 *
 *  \note The video drivers are presented in the order in which they are
 *        normally checked during initialization.
 *
 *  \sa SDL_GetNumVideoDrivers()
 */
pub extern (C) def SDL_GetVideoDriver (index : i32)-> &(c8);

/**
 *  \brief Initialize the video subsystem, optionally specifying a video driver.
 *
 *  \param driver_name Initialize a specific driver by name, or NULL for the
 *                     default video driver.
 *
 *  \return 0 on success, -1 on error
 *
 *  This function initializes the video subsystem; setting up a connection
 *  to the window manager, etc, and determines the available display modes
 *  and pixel formats, but does not initialize a window or graphics mode.
 *
 *  \sa SDL_VideoQuit()
 */
pub extern (C) def SDL_VideoInit(driver_name : &c8)-> i32;

/**
 *  \brief Shuts down the video subsystem.
 *
 *  This function closes all windows, and restores the original video mode.
 *
 *  \sa SDL_VideoInit()
 */
pub extern (C) def SDL_VideoQuit()-> void;

/**
 *  \brief Returns the name of the currently initialized video driver.
 *
 *  \return The name of the current video driver or NULL if no driver
 *          has been initialized
 *
 *  \sa SDL_GetNumVideoDrivers()
 *  \sa SDL_GetVideoDriver()
 */
pub extern (C) def SDL_GetCurrentVideoDriver()-> &c8;

/**
 *  \brief Returns the number of available video displays.
 *
 *  \sa SDL_GetDisplayBounds()
 */
pub extern (C) def SDL_GetNumVideoDisplays()-> i32;

/**
 *  \brief Get the name of a display in UTF-8 encoding
 *
 *  \return The name of a display, or NULL for an invalid display index.
 *
 *  \sa SDL_GetNumVideoDisplays()
 */
pub extern (C) def SDL_GetDisplayName(displayIndex : i32)-> &c8;

/**
 *  \brief Get the desktop area represented by a display, with the primary
 *         display located at 0,0
 *
 *  \return 0 on success, or -1 if the index is out of range.
 *
 *  \sa SDL_GetNumVideoDisplays()
 */
pub extern (C) def SDL_GetDisplayBounds(displayIndex : i32, dmut rect : &SDL_Rect)-> i32;

/**
 *  \brief Get the usable desktop area represented by a display, with the
 *         primary display located at 0,0
 *
 *  This is the same area as SDL_GetDisplayBounds() reports, but with portions
 *  reserved by the system removed. For example, on Mac OS X, this subtracts
 *  the area occupied by the menu bar and dock.
 *
 *  Setting a window to be fullscreen generally bypasses these unusable areas,
 *  so these are good guidelines for the maximum space available to a
 *  non-fullscreen window.
 *
 *  \return 0 on success, or -1 if the index is out of range.
 *
 *  \sa SDL_GetDisplayBounds()
 *  \sa SDL_GetNumVideoDisplays()
 */
pub extern (C) def SDL_GetDisplayUsableBounds(displayIndex : i32, dmut rect : &SDL_Rect) -> i32;

/**
 *  \brief Get the dots/pixels-per-inch for a display
 *
 *  \note Diagonal, horizontal and vertical DPI can all be optionally
 *        returned if the parameter is non-NULL.
 *
 *  \return 0 on success, or -1 if no DPI information is available or the index is out of range.
 *
 *  \sa SDL_GetNumVideoDisplays()
 */
pub extern (C) def SDL_GetDisplayDPI(displayIndex : i32, dmut ddpi : &f32, dmut hdpi : &f32, dmut vdpi : &f32)-> i32;

/**
 *  \brief Get the orientation of a display
 *
 *  \return The orientation of the display, or SDL_ORIENTATION_UNKNOWN if it isn't available.
 *
 *  \sa SDL_GetNumVideoDisplays()
 */
pub extern (C) def SDL_GetDisplayOrientation(displayIndex : i32)-> SDL_DisplayOrientation ;

/**
 *  \brief Returns the number of available display modes.
 *
 *  \sa SDL_GetDisplayMode()
 */
pub extern (C) def SDL_GetNumDisplayModes(displayIndex : i32)-> i32;

/**
 *  \brief Fill in information about a specific display mode.
 *
 *  \note The display modes are sorted in this priority:
 *        \li bits per pixel -> more colors to fewer colors
 *        \li width -> largest to smallest
 *        \li height -> largest to smallest
 *        \li refresh rate -> highest to lowest
 *
 *  \sa SDL_GetNumDisplayModes()
 */
pub extern (C) def SDL_GetDisplayMode(displayIndex : i32, modeIndex : i32,
                                               dmut mode: &SDL_DisplayMode)-> i32;

/**
 *  \brief Fill in information about the desktop display mode.
 */
pub extern (C) def SDL_GetDesktopDisplayMode(displayIndex : i32, dmut mode : &SDL_DisplayMode)-> i32;

/**
 *  \brief Fill in information about the current display mode.
 */
pub extern (C) def SDL_GetCurrentDisplayMode(displayIndex : i32, dmut mode : &SDL_DisplayMode);


/**
 *  \brief Get the closest match to the requested display mode.
 *
 *  \param displayIndex The index of display from which mode should be queried.
 *  \param mode The desired display mode
 *  \param closest A pointer to a display mode to be filled in with the closest
 *                 match of the available display modes.
 *
 *  \return The passed in value \c closest, or NULL if no matching video mode
 *          was available.
 *
 *  The available display modes are scanned, and \c closest is filled in with the
 *  closest mode matching the requested mode and returned.  The mode format and
 *  refresh_rate default to the desktop mode if they are 0.  The modes are
 *  scanned with size being first priority, format being second priority, and
 *  finally checking the refresh_rate.  If all the available modes are too
 *  small, then NULL is returned.
 *
 *  \sa SDL_GetNumDisplayModes()
 *  \sa SDL_GetDisplayMode()
 */
pub extern (C) def DL_GetClosestDisplayMode(displayIndex : i32, mode : &SDL_DisplayMode, dmut closest : &SDL_DisplayMode)-> &SDL_DisplayMode;

/**
 *  \brief Get the display index associated with a window.
 *
 *  \return the display index of the display containing the center of the
 *          window, or -1 on error.
 */
pub extern (C) def SDL_GetWindowDisplayIndex(window : &SDL_Window)-> i32;

/**
 *  \brief Set the display mode used when a fullscreen window is visible.
 *
 *  By default the window's dimensions and the desktop format and refresh rate
 *  are used.
 *
 *  \param window The window for which the display mode should be set.
 *  \param mode The mode to use, or NULL for the default mode.
 *
 *  \return 0 on success, or -1 if setting the display mode failed.
 *
 *  \sa SDL_GetWindowDisplayMode()
 *  \sa SDL_SetWindowFullscreen()
 */
pub extern (C) def SDL_SetWindowDisplayMode(dmut window : &SDL_Window,                                                     
                                        mode : &SDL_DisplayMode)-> i32;

/**
 *  \brief Fill in information about the display mode used when a fullscreen
 *         window is visible.
 *
 *  \sa SDL_SetWindowDisplayMode()
 *  \sa SDL_SetWindowFullscreen()
 */
pub extern (C) def SDL_GetWindowDisplayMode(window : &SDL_Window,
                                        mode : &SDL_DisplayMode)-> i32;

/**
 *  \brief Get the pixel format associated with the window.
 */
pub extern (C) def SDL_GetWindowPixelFormat(window : &SDL_Window)-> u32;

/**
 *  \brief Create a window with the specified position, dimensions, and flags.
 *
 *  \param title The title of the window, in UTF-8 encoding.
 *  \param x     The x position of the window, ::SDL_WINDOWPOS_CENTERED, or
 *               ::SDL_WINDOWPOS_UNDEFINED.
 *  \param y     The y position of the window, ::SDL_WINDOWPOS_CENTERED, or
 *               ::SDL_WINDOWPOS_UNDEFINED.
 *  \param w     The width of the window, in screen coordinates.
 *  \param h     The height of the window, in screen coordinates.
 *  \param flags The flags for the window, a mask of any of the following:
 *               ::SDL_WINDOW_FULLSCREEN,    ::SDL_WINDOW_OPENGL,
 *               ::SDL_WINDOW_HIDDEN,        ::SDL_WINDOW_BORDERLESS,
 *               ::SDL_WINDOW_RESIZABLE,     ::SDL_WINDOW_MAXIMIZED,
 *               ::SDL_WINDOW_MINIMIZED,     ::SDL_WINDOW_INPUT_GRABBED,
 *               ::SDL_WINDOW_ALLOW_HIGHDPI, ::SDL_WINDOW_VULKAN.
 *
 *  \return The created window, or NULL if window creation failed.
 *
 *  If the window is created with the SDL_WINDOW_ALLOW_HIGHDPI flag, its size
 *  in pixels may differ from its size in screen coordinates on platforms with
 *  high-DPI support (e.g. iOS and Mac OS X). Use SDL_GetWindowSize() to query
 *  the client area's size in screen coordinates, and SDL_GL_GetDrawableSize(),
 *  SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to query the
 *  drawable size in pixels.
 *
 *  If the window is created with any of the SDL_WINDOW_OPENGL or
 *  SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function
 *  (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the
 *  corresponding UnloadLibrary function is called by SDL_DestroyWindow().
 *
 *  If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,
 *  SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.
 *
 *  \note On non-Apple devices, SDL requires you to either not link to the
 *        Vulkan loader or link to a dynamic library version. This limitation
 *        may be removed in a future version of SDL.
 *
 *  \sa SDL_DestroyWindow()
 *  \sa SDL_GL_LoadLibrary()
 *  \sa SDL_Vulkan_LoadLibrary()
 */
pub extern (C) def SDL_CreateWindow(title : &c8,
                                x : i32, y : i32, w : i32,
                                h : i32, flags : u32)-> dmut &(SDL_Window);

/**
 *  \brief Create an SDL window from an existing native window.
 *
 *  \param data A pointer to driver-dependent window creation data
 *
 *  \return The created window, or NULL if window creation failed.
 *
 *  \sa SDL_DestroyWindow()
 */
pub extern (C) def SDL_CreateWindowFrom(data : &(void))-> dmut &SDL_Window;

/**
 *  \brief Get the numeric ID of a window, for logging purposes.
 */
pub extern (C) def SDL_GetWindowID(window : &SDL_Window)-> u32;

/**
 *  \brief Get a window from a stored ID, or NULL if it doesn't exist.
 */
pub extern (C) def SDL_GetWindowFromID(id : u32)-> &SDL_Window;

/**
 *  \brief Get the window flags.
 */
pub extern (C) def SDL_GetWindowFlags(window : &SDL_Window)-> u32;

/**
 *  \brief Set the title of a window, in UTF-8 format.
 *
 *  \sa SDL_GetWindowTitle()
 */
pub extern (C) def SDL_SetWindowTitle(dmut window : &SDL_Window,
                                  title : &c8);

/**
 *  \brief Get the title of a window, in UTF-8 format.
 *
 *  \sa SDL_SetWindowTitle()
 */
pub extern (C) def SDL_GetWindowTitle(window : &SDL_Window)-> &c8;

/**
 *  \brief Set the icon for a window.
 *
 *  \param window The window for which the icon should be set.
 *  \param icon The icon for the window.
 */
pub extern (C) def SDL_SetWindowIcon(dmut window : &SDL_Window,
                                 icon : &SDL_Surface);


/**
 *  \brief Set the position of a window.
 *
 *  \param window   The window to reposition.
 *  \param x        The x coordinate of the window in screen coordinates, or
 *                  ::SDL_WINDOWPOS_CENTERED or ::SDL_WINDOWPOS_UNDEFINED.
 *  \param y        The y coordinate of the window in screen coordinates, or
 *                  ::SDL_WINDOWPOS_CENTERED or ::SDL_WINDOWPOS_UNDEFINED.
 *
 *  \note The window coordinate origin is the upper left of the display.
 *
 *  \sa SDL_GetWindowPosition()
 */
pub extern (C) def SDL_SetWindowPosition(dmut window : &SDL_Window,
                                     x : i32, y : i32);

/**
 *  \brief Get the position of a window.
 *
 *  \param window   The window to query.
 *  \param x        Pointer to variable for storing the x position, in screen
 *                  coordinates. May be NULL.
 *  \param y        Pointer to variable for storing the y position, in screen
 *                  coordinates. May be NULL.
 *
 *  \sa SDL_SetWindowPosition()
 */
pub extern (C) def SDL_GetWindowPosition(window : &SDL_Window,
                                     dmut x : &i32, dmut y : &i32);

/**
 *  \brief Set the size of a window's client area.
 *
 *  \param window   The window to resize.
 *  \param w        The width of the window, in screen coordinates. Must be >0.
 *  \param h        The height of the window, in screen coordinates. Must be >0.
 *
 *  \note Fullscreen windows automatically match the size of the display mode,
 *        and you should use SDL_SetWindowDisplayMode() to change their size.
 *
 *  The window size in screen coordinates may differ from the size in pixels, if
 *  the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a platform with
 *  high-dpi support (e.g. iOS or OS X). Use SDL_GL_GetDrawableSize() or
 *  SDL_GetRendererOutputSize() to get the real client area size in pixels.
 *
 *  \sa SDL_GetWindowSize()
 *  \sa SDL_SetWindowDisplayMode()
 */
pub extern (C) def SDL_SetWindowSize(dmut window : &SDL_Window, w : i32,
                                 h : i32);

/**
 *  \brief Get the size of a window's client area.
 *
 *  \param window   The window to query.
 *  \param w        Pointer to variable for storing the width, in screen
 *                  coordinates. May be NULL.
 *  \param h        Pointer to variable for storing the height, in screen
 *                  coordinates. May be NULL.
 *
 *  The window size in screen coordinates may differ from the size in pixels, if
 *  the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a platform with
 *  high-dpi support (e.g. iOS or OS X). Use SDL_GL_GetDrawableSize() or
 *  SDL_GetRendererOutputSize() to get the real client area size in pixels.
 *
 *  \sa SDL_SetWindowSize()
 */
pub extern (C) def SDL_GetWindowSize(window : &SDL_Window, dmut w : &i32,
                                 dmut h : &i32);

/**
 *  \brief Get the size of a window's borders (decorations) around the client area.
 *
 *  \param window The window to query.
 *  \param top Pointer to variable for storing the size of the top border. NULL is permitted.
 *  \param left Pointer to variable for storing the size of the left border. NULL is permitted.
 *  \param bottom Pointer to variable for storing the size of the bottom border. NULL is permitted.
 *  \param right Pointer to variable for storing the size of the right border. NULL is permitted.
 *
 *  \return 0 on success, or -1 if getting this information is not supported.
 *
 *  \note if this function fails (returns -1), the size values will be
 *        initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as
 *        if the window in question was borderless.
 */
pub extern (C) def SDL_GetWindowBordersSize(window : &SDL_Window,
                                                     dmut top : &i32, dmut left : &i32,
                                                     dmut bottom : &i32, dmut right : &i32)-> i32;

/**
 *  \brief Set the minimum size of a window's client area.
 *
 *  \param window    The window to set a new minimum size.
 *  \param min_w     The minimum width of the window, must be >0
 *  \param min_h     The minimum height of the window, must be >0
 *
 *  \note You can't change the minimum size of a fullscreen window, it
 *        automatically matches the size of the display mode.
 *
 *  \sa SDL_GetWindowMinimumSize()
 *  \sa SDL_SetWindowMaximumSize()
 */
pub extern (C) def SDL_SetWindowMinimumSize(dmut window : &SDL_Window,
                                        min_w : i32, min_h : i32);

/**
 *  \brief Get the minimum size of a window's client area.
 *
 *  \param window   The window to query.
 *  \param w        Pointer to variable for storing the minimum width, may be NULL
 *  \param h        Pointer to variable for storing the minimum height, may be NULL
 *
 *  \sa SDL_GetWindowMaximumSize()
 *  \sa SDL_SetWindowMinimumSize()
 */
pub extern (C) def SDL_GetWindowMinimumSize(window : &SDL_Window,
                                        dmut w : &i32, dmut h : &i32);

/**
 *  \brief Set the maximum size of a window's client area.
 *
 *  \param window    The window to set a new maximum size.
 *  \param max_w     The maximum width of the window, must be >0
 *  \param max_h     The maximum height of the window, must be >0
 *
 *  \note You can't change the maximum size of a fullscreen window, it
 *        automatically matches the size of the display mode.
 *
 *  \sa SDL_GetWindowMaximumSize()
 *  \sa SDL_SetWindowMinimumSize()
 */
pub extern (C) def SDL_SetWindowMaximumSize(dmut window : &SDL_Window,
                                        max_w : i32, max_h : i32)
;
/**
 *  \brief Get the maximum size of a window's client area.
 *
 *  \param window   The window to query.
 *  \param w        Pointer to variable for storing the maximum width, may be NULL
 *  \param h        Pointer to variable for storing the maximum height, may be NULL
 *
 *  \sa SDL_GetWindowMinimumSize()
 *  \sa SDL_SetWindowMaximumSize()
 */
pub extern (C) def SDL_GetWindowMaximumSize(window : &SDL_Window,
                                        dmut w : &i32, dmut h : &i32);

/**
 *  \brief Set the border state of a window.
 *
 *  This will add or remove the window's SDL_WINDOW_BORDERLESS flag and
 *  add or remove the border from the actual window. This is a no-op if the
 *  window's border already matches the requested state.
 *
 *  \param window The window of which to change the border state.
 *  \param bordered SDL_FALSE to remove border, SDL_TRUE to add border.
 *
 *  \note You can't change the border state of a fullscreen window.
 *
 *  \sa SDL_GetWindowFlags()
 */
pub extern (C) def SDL_SetWindowBordered(dmut window : &SDL_Window,
                                     bordered : bool);

/**
 *  \brief Set the user-resizable state of a window.
 *
 *  This will add or remove the window's SDL_WINDOW_RESIZABLE flag and
 *  allow/disallow user resizing of the window. This is a no-op if the
 *  window's resizable state already matches the requested state.
 *
 *  \param window The window of which to change the resizable state.
 *  \param resizable SDL_TRUE to allow resizing, SDL_FALSE to disallow.
 *
 *  \note You can't change the resizable state of a fullscreen window.
 *
 *  \sa SDL_GetWindowFlags()
 */
pub extern (C) def SDL_SetWindowResizable(dmut window : &SDL_Window,
                                      resizable : bool);

/**
 *  \brief Show a window.
 *
 *  \sa SDL_HideWindow()
 */
pub extern (C) def SDL_ShowWindow(dmut window : &SDL_Window);

/**
 *  \brief Hide a window.
 *
 *  \sa SDL_ShowWindow()
 */
pub extern (C) def SDL_HideWindow(dmut window : &SDL_Window);

/**
 *  \brief Raise a window above other windows and set the input focus.
 */
pub extern (C) def SDL_RaiseWindow(dmut window : &SDL_Window);

/**
 *  \brief Make a window as large as possible.
 *
 *  \sa SDL_RestoreWindow()
 */
pub extern (C) def SDL_MaximizeWindow(dmut window : &SDL_Window);

/**
 *  \brief Minimize a window to an iconic representation.
 *
 *  \sa SDL_RestoreWindow()
 */
pub extern (C) def SDL_MinimizeWindow(dmut window : &SDL_Window);

/**
 *  \brief Restore the size and position of a minimized or maximized window.
 *
 *  \sa SDL_MaximizeWindow()
 *  \sa SDL_MinimizeWindow()
 */
pub extern (C) def SDL_RestoreWindow(dmut window : &SDL_Window);

/**
 *  \brief Set a window's fullscreen state.
 *
 *  \return 0 on success, or -1 if setting the display mode failed.
 *
 *  \sa SDL_SetWindowDisplayMode()
 *  \sa SDL_GetWindowDisplayMode()
 */
pub extern (C) def SDL_SetWindowFullscreen(dmut window : &SDL_Window,
                                       flags : u32)-> i32;

/**
 *  \brief Get the SDL surface associated with the window.
 *
 *  \return The window's framebuffer surface, or NULL on error.
 *
 *  A new surface will be created with the optimal format for the window,
 *  if necessary. This surface will be freed when the window is destroyed.
 *
 *  \note You may not combine this with 3D or the rendering API on this window.
 *
 *  \sa SDL_UpdateWindowSurface()
 *  \sa SDL_UpdateWindowSurfaceRects()
 */
pub extern (C) def SDL_GetWindowSurface(window : &SDL_Window)-> &SDL_Surface;

/**
 *  \brief Copy the window surface to the screen.
 *
 *  \return 0 on success, or -1 on error.
 *
 *  \sa SDL_GetWindowSurface()
 *  \sa SDL_UpdateWindowSurfaceRects()
 */
pub extern (C) def SDL_UpdateWindowSurface(dmut window : &SDL_Window)-> i32;

/**
 *  \brief Copy a number of rectangles on the window surface to the screen.
 *
 *  \return 0 on success, or -1 on error.
 *
 *  \sa SDL_GetWindowSurface()
 *  \sa SDL_UpdateWindowSurface()
 */
pub extern (C) def SDL_UpdateWindowSurfaceRects(dmut window : &SDL_Window,
                                            rects : &SDL_Surface,
                                            numrects : i32)-> i32;

/**
 *  \brief Set a window's input grab mode.
 *
 *  \param window The window for which the input grab mode should be set.
 *  \param grabbed This is SDL_TRUE to grab input, and SDL_FALSE to release input.
 *
 *  If the caller enables a grab while another window is currently grabbed,
 *  the other window loses its grab in favor of the caller's window.
 *
 *  \sa SDL_GetWindowGrab()
 */
pub extern (C) def SDL_SetWindowGrab(dmut window : &SDL_Window,
                                 grabbed : bool);

/**
 *  \brief Get a window's input grab mode.
 *
 *  \return This returns SDL_TRUE if input is grabbed, and SDL_FALSE otherwise.
 *
 *  \sa SDL_SetWindowGrab()
 */
pub extern (C) def SDL_GetWindowGrab(window : &SDL_Window)-> bool;

/**
 *  \brief Get the window that currently has an input grab enabled.
 *
 *  \return This returns the window if input is grabbed, and NULL otherwise.
 *
 *  \sa SDL_SetWindowGrab()
 */
pub extern (C) def SDL_GetGrabbedWindow()-> &SDL_Window;

/**
 *  \brief Set the brightness (gamma correction) for a window.
 *
 *  \return 0 on success, or -1 if setting the brightness isn't supported.
 *
 *  \sa SDL_GetWindowBrightness()
 *  \sa SDL_SetWindowGammaRamp()
 */
pub extern (C) def SDL_SetWindowBrightness(dmut window : &SDL_Window, brightness : f32)-> i32;

/**
 *  \brief Get the brightness (gamma correction) for a window.
 *
 *  \return The last brightness value passed to SDL_SetWindowBrightness()
 *
 *  \sa SDL_SetWindowBrightness()
 */
pub extern (C) def SDL_GetWindowBrightness(window : &SDL_Window)-> f32;

/**
 *  \brief Set the opacity for a window
 *
 *  \param window The window which will be made transparent or opaque
 *  \param opacity Opacity (0.0f - transparent, 1.0f - opaque) This will be
 *                 clamped internally between 0.0f and 1.0f.
 *
 *  \return 0 on success, or -1 if setting the opacity isn't supported.
 *
 *  \sa SDL_GetWindowOpacity()
 */
pub extern (C) def SDL_SetWindowOpacity(dmut window : &SDL_Window, opacity : f32);

/**
 *  \brief Get the opacity of a window.
 *
 *  If transparency isn't supported on this platform, opacity will be reported
 *  as 1.0f without error.
 *
 *  \param window The window in question.
 *  \param out_opacity Opacity (0.0f - transparent, 1.0f - opaque)
 *
 *  \return 0 on success, or -1 on error (invalid window, etc).
 *
 *  \sa SDL_SetWindowOpacity()
 */
pub extern (C) def SDL_GetWindowOpacity(window : &SDL_Window, dmut out_opacity : &f32);

/**
 *  \brief Sets the window as a modal for another window (TODO: reconsider this function and/or its name)
 *
 *  \param modal_window The window that should be modal
 *  \param parent_window The parent window
 *
 *  \return 0 on success, or -1 otherwise.
 */
pub extern (C) def SDL_SetWindowModalFor(dmut modal_window : &SDL_Window, dmut parent_window : &SDL_Window)-> i32;

/**
 *  \brief Explicitly sets input focus to the window.
 *
 *  You almost certainly want SDL_RaiseWindow() instead of this function. Use
 *  this with caution, as you might give focus to a window that's completely
 *  obscured by other windows.
 *
 *  \param window The window that should get the input focus
 *
 *  \return 0 on success, or -1 otherwise.
 *  \sa SDL_RaiseWindow()
 */
pub extern (C) def SDL_SetWindowInputFocus(dmut window : &SDL_Window)-> i32;

/**
 *  \brief Set the gamma ramp for a window.
 *
 *  \param window The window for which the gamma ramp should be set.
 *  \param red The translation table for the red channel, or NULL.
 *  \param green The translation table for the green channel, or NULL.
 *  \param blue The translation table for the blue channel, or NULL.
 *
 *  \return 0 on success, or -1 if gamma ramps are unsupported.
 *
 *  Set the gamma translation table for the red, green, and blue channels
 *  of the video hardware.  Each table is an array of 256 16-bit quantities,
 *  representing a mapping between the input and output for that channel.
 *  The input is the index into the array, and the output is the 16-bit
 *  gamma value at that index, scaled to the output color precision.
 *
 *  \sa SDL_GetWindowGammaRamp()
 */
pub extern (C) def SDL_SetWindowGammaRamp(dmut window : &SDL_Window,
                                      red : &u16,
                                      green : &u16,
                                      blue : &u16)-> i32;

/**
 *  \brief Get the gamma ramp for a window.
 *
 *  \param window The window from which the gamma ramp should be queried.
 *  \param red   A pointer to a 256 element array of 16-bit quantities to hold
 *               the translation table for the red channel, or NULL.
 *  \param green A pointer to a 256 element array of 16-bit quantities to hold
 *               the translation table for the green channel, or NULL.
 *  \param blue  A pointer to a 256 element array of 16-bit quantities to hold
 *               the translation table for the blue channel, or NULL.
 *
 *  \return 0 on success, or -1 if gamma ramps are unsupported.
 *
 *  \sa SDL_SetWindowGammaRamp()
 */
pub extern (C) def SDL_GetWindowGammaRamp(window : &SDL_Window,
                                                   dmut red : &u16,
                                                   dmut green : &u16,
                                                   blue : &u16)-> i32;

/**
 *  \brief Possible return values from the SDL_HitTest callback.
 *
 *  \sa SDL_HitTest
 */
pub enum
| SDL_HITTEST_NORMAL = 0  /**< Region is normal. No special properties. */
| SDL_HITTEST_DRAGGABLE = 1 /**< Region can drag entire window. */
| SDL_HITTEST_RESIZE_TOPLEFT = 2
| SDL_HITTEST_RESIZE_TOP = 3
| SDL_HITTEST_RESIZE_TOPRIGHT = 4
| SDL_HITTEST_RESIZE_RIGHT = 5
| SDL_HITTEST_RESIZE_BOTTOMRIGHT = 6
| SDL_HITTEST_RESIZE_BOTTOM = 7
| SDL_HITTEST_RESIZE_BOTTOMLEFT = 8
| SDL_HITTEST_RESIZE_LEFT = 9
-> SDL_HitTestResult;

/**
 *  \brief Callback used for hit-testing.
 *
 *  \sa SDL_SetWindowHitTest
 */
aka SDL_HitTest = fn (&SDL_Window, &SDL_Point, &void)-> SDL_HitTestResult;

/**
 *  \brief Provide a callback that decides if a window region has special properties.
 *
 *  Normally windows are dragged and resized by decorations provided by the
 *  system window manager (a title bar, borders, etc), but for some apps, it
 *  makes sense to drag them from somewhere else inside the window itself; for
 *  example, one might have a borderless window that wants to be draggable
 *  from any part, or simulate its own title bar, etc.
 *
 *  This function lets the app provide a callback that designates pieces of
 *  a given window as special. This callback is run during event processing
 *  if we need to tell the OS to treat a region of the window specially; the
 *  use of this callback is known as "hit testing."
 *
 *  Mouse input may not be delivered to your application if it is within
 *  a special area; the OS will often apply that input to moving the window or
 *  resizing the window and not deliver it to the application.
 *
 *  Specifying NULL for a callback disables hit-testing. Hit-testing is
 *  disabled by default.
 *
 *  Platforms that don't support this functionality will return -1
 *  unconditionally, even if you're attempting to disable hit-testing.
 *
 *  Your callback may fire at any time, and its firing does not indicate any
 *  specific behavior (for example, on Windows, this certainly might fire
 *  when the OS is deciding whether to drag your window, but it fires for lots
 *  of other reasons, too, some unrelated to anything you probably care about
 *  _and when the mouse isn't actually at the location it is testing_).
 *  Since this can fire at any time, you should try to keep your callback
 *  efficient, devoid of allocations, etc.
 *
 *  \param window The window to set hit-testing on.
 *  \param callback The callback to call when doing a hit-test.
 *  \param callback_data An app-defined void pointer passed to the callback.
 *  \return 0 on success, -1 on error (including unsupported).
 */
pub extern (C) def SDL_SetWindowHitTest(dmut window : &SDL_Window,
                                    callback : SDL_HitTest,
                                    callback_data : &void)-> i32;

/**
 *  \brief Destroy a window.
 */
pub extern (C) def SDL_DestroyWindow(window : &SDL_Window);


/**
 *  \brief Returns whether the screensaver is currently enabled (default off).
 *
 *  \sa SDL_EnableScreenSaver()
 *  \sa SDL_DisableScreenSaver()
 */
pub extern (C) def SDL_IsScreenSaverEnabled()-> bool;

/**
 *  \brief Allow the screen to be blanked by a screensaver
 *
 *  \sa SDL_IsScreenSaverEnabled()
 *  \sa SDL_DisableScreenSaver()
 */
pub extern (C) def SDL_EnableScreenSaver();

/**
 *  \brief Prevent the screen from being blanked by a screensaver
 *
 *  \sa SDL_IsScreenSaverEnabled()
 *  \sa SDL_EnableScreenSaver()
 */
pub extern (C) def SDL_DisableScreenSaver();


/**
 *  \name OpenGL support functions
 */
/* @{ */

/**
 *  \brief Dynamically load an OpenGL library.
 *
 *  \param path The platform dependent OpenGL library name, or NULL to open the
 *              default OpenGL library.
 *
 *  \return 0 on success, or -1 if the library couldn't be loaded.
 *
 *  This should be done after initializing the video driver, but before
 *  creating any OpenGL windows.  If no OpenGL library is loaded, the default
 *  library will be loaded upon creation of the first OpenGL window.
 *
 *  \note If you do this, you need to retrieve all of the GL functions used in
 *        your program from the dynamic library using SDL_GL_GetProcAddress().
 *
 *  \sa SDL_GL_GetProcAddress()
 *  \sa SDL_GL_UnloadLibrary()
 */
pub extern (C) def SDL_GL_LoadLibrary(path : &c8)-> i32;

/**
 *  \brief Get the address of an OpenGL function.
 */
pub extern (C) def SDL_GL_GetProcAddress(proc : &c8)-> &void;

/**
 *  \brief Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().
 *
 *  \sa SDL_GL_LoadLibrary()
 */
pub extern (C) def SDL_GL_UnloadLibrary();

/**
 *  \brief Return true if an OpenGL extension is supported for the current
 *         context.
 */
pub extern (C) def SDL_GL_ExtensionSupported(extension : &c8)-> bool;

/**
 *  \brief Reset all previously set OpenGL context attributes to their default values
 */
pub extern (C) def SDL_GL_ResetAttributes();

/**
 *  \brief Set an OpenGL window attribute before window creation.
 *
 *  \return 0 on success, or -1 if the attribute could not be set.
 */
pub extern (C) def SDL_GL_SetAttribute(attr : SDL_GLattr, value : i32)-> i32;

/**
 *  \brief Get the actual value for an attribute from the current context.
 *
 *  \return 0 on success, or -1 if the attribute could not be retrieved.
 *          The integer at \c value will be modified in either case.
 */
pub extern (C) def SDL_GL_GetAttribute(attr : SDL_GLattr, dmut value : &i32)-> i32;

/**
 *  \brief Create an OpenGL context for use with an OpenGL window, and make it
 *         current.
 *
 *  \sa SDL_GL_DeleteContext()
 */
pub extern (C) def SDL_GL_CreateContext(dmut window : &SDL_Window)-> dmut &SDL_GLContext;

/**
 *  \brief Set up an OpenGL context for rendering into an OpenGL window.
 *
 *  \note The context must have been created with a compatible window.
 */
pub extern (C) def SDL_GL_MakeCurrent(dmut window : &SDL_Window,
                                  context : &SDL_GLContext);

/**
 *  \brief Get the currently active OpenGL window.
 */
pub extern (C) def SDL_GL_GetCurrentWindow()-> &SDL_Window;

/**
 *  \brief Get the currently active OpenGL context.
 */
pub extern (C) def SDL_GL_GetCurrentContext()-> &SDL_GLContext;

/**
 *  \brief Get the size of a window's underlying drawable in pixels (for use
 *         with glViewport).
 *
 *  \param window   Window from which the drawable size should be queried
 *  \param w        Pointer to variable for storing the width in pixels, may be NULL
 *  \param h        Pointer to variable for storing the height in pixels, may be NULL
 *
 * This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI
 * drawable, i.e. the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a
 * platform with high-DPI support (Apple calls this "Retina"), and not disabled
 * by the SDL_HINT_VIDEO_HIGHDPI_DISABLED hint.
 *
 *  \sa SDL_GetWindowSize()
 *  \sa SDL_CreateWindow()
 */
pub extern (C) def SDL_GL_GetDrawableSize(window : &SDL_Window, dmut w : &i32,
                                      dmut h : &i32);

/**
 *  \brief Set the swap interval for the current OpenGL context.
 *
 *  \param interval 0 for immediate updates, 1 for updates synchronized with the
 *                  vertical retrace. If the system supports it, you may
 *                  specify -1 to allow late swaps to happen immediately
 *                  instead of waiting for the next retrace.
 *
 *  \return 0 on success, or -1 if setting the swap interval is not supported.
 *
 *  \sa SDL_GL_GetSwapInterval()
 */
pub extern (C) def SDL_GL_SetSwapInterval(interval : i32)-> i32;

/**
 *  \brief Get the swap interval for the current OpenGL context.
 *
 *  \return 0 if there is no vertical retrace synchronization, 1 if the buffer
 *          swap is synchronized with the vertical retrace, and -1 if late
 *          swaps happen immediately instead of waiting for the next retrace.
 *          If the system can't determine the swap interval, or there isn't a
 *          valid current context, this will return 0 as a safe default.
 *
 *  \sa SDL_GL_SetSwapInterval()
 */
pub extern (C) def SDL_GL_GetSwapInterval()-> i32;

/**
 * \brief Swap the OpenGL buffers for a window, if double-buffering is
 *        supported.
 */
pub extern (C) def SDL_GL_SwapWindow(dmut window : &SDL_Window);

/**
 *  \brief Delete an OpenGL context.
 *
 *  \sa SDL_GL_CreateContext()
 */
pub extern (C) def SDL_GL_DeleteContext(dmut context : &SDL_GLContext);

/* @} *//* OpenGL support functions */
